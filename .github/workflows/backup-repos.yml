name: Repository Backup (Alternative)

on:
    schedule:
        - cron: "0 2 * * *" # Daily at 2 AM UTC
    workflow_dispatch:

env:
    AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
    AZURE_STORAGE_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
    GITHUB_TOKEN: ${{ secrets.BACKUP_TOKEN }}
    WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
    CONTAINER_NAME: "repo-backups"
    RETENTION_DAYS: 10

jobs:
    backup:
        runs-on: ubuntu-latest
        timeout-minutes: 120

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Azure CLI
              run: |
                  curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
                  sudo apt-get update && sudo apt-get install -y jq

                  # Ensure container exists
                  az storage container create \
                    --account-name "$AZURE_STORAGE_ACCOUNT" \
                    --account-key "$AZURE_STORAGE_KEY" \
                    --name "$CONTAINER_NAME" \
                    --public-access off || true

            - name: Backup Repositories
              run: |
                  set -e

                  # Initialize counters
                  SUCCESS_COUNT=0
                  FAIL_COUNT=0
                  FAILED_REPOS=""
                  DATE_PREFIX=$(date +%Y%m%d_%H%M%S)

                  # Function to send webhook (Teams/Power Automate compatible)
                  send_webhook() {
                    if [ -z "$WEBHOOK_URL" ]; then
                      return 0
                    fi
                    
                    local success="$1"
                    local message="$2"
                    local color=$([ "$success" = "true" ] && echo "00FF00" || echo "FF0000")
                    local status=$([ "$success" = "true" ] && echo "‚úÖ Success" || echo "‚ùå Failed")
                    
                    # Create adaptive card format for Teams/Power Automate
                    local payload=$(cat <<EOF
                  {
                    "@type": "MessageCard",
                    "@context": "http://schema.org/extensions",
                    "themeColor": "$color",
                    "summary": "Repository Backup $status",
                    "sections": [{
                      "activityTitle": "GitHub Repository Backup",
                      "activitySubtitle": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
                      "activityImage": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
                      "facts": [
                        {
                          "name": "Status",
                          "value": "$status"
                        },
                        {
                          "name": "Result",
                          "value": "$message"
                        },
                        {
                          "name": "Workflow",
                          "value": "repository-backup"
                        },
                        {
                          "name": "Run ID",
                          "value": "${GITHUB_RUN_ID:-N/A}"
                        }
                      ],
                      "markdown": true
                    }],
                    "potentialAction": [{
                      "@type": "OpenUri",
                      "name": "View Workflow Run",
                      "targets": [{
                        "os": "default",
                        "uri": "https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID:-}"
                      }]
                    }],
                    "attachments": [{
                      "contentType": "application/vnd.microsoft.card.adaptive",
                      "content": {
                        "type": "AdaptiveCard",
                        "version": "1.0",
                        "body": [
                          {
                            "type": "TextBlock",
                            "size": "Medium",
                            "weight": "Bolder",
                            "text": "Repository Backup $status"
                          },
                          {
                            "type": "TextBlock",
                            "text": "$message",
                            "wrap": true
                          }
                        ]
                      }
                    }]
                  }
                  EOF
                  )
                    
                    curl -X POST "$WEBHOOK_URL" \
                      -H "Content-Type: application/json" \
                      -d "$payload" \
                      --max-time 10 || true
                  }

                  # Function to backup a single repository
                  backup_repo() {
                    local repo_url="$1"
                    local repo_name=$(basename "$repo_url" .git)
                    local temp_dir=$(mktemp -d)
                    
                    echo "üì¶ Backing up: $repo_name ($repo_url)"
                    
                    # Clone repository
                    if [ -n "$GITHUB_TOKEN" ] && [[ "$repo_url" == *"github.com"* ]]; then
                      # Add token for private repos
                      local auth_url="https://${GITHUB_TOKEN}@${repo_url#https://}"
                    else
                      local auth_url="$repo_url"
                    fi
                    
                    # Clone with stdin redirected to prevent any consumption issues
                    if ! git clone --mirror "$auth_url" "$temp_dir/$repo_name" </dev/null 2>/dev/null; then
                      echo "‚ùå Failed to clone: $repo_name"
                      rm -rf "$temp_dir"
                      return 1
                    fi
                    
                    # Create archive
                    local archive_name="${repo_name}_${DATE_PREFIX}.zip"
                    local archive_path="$temp_dir/$archive_name"
                    
                    (cd "$temp_dir" && zip -qr "$archive_name" "$repo_name")
                    
                    if [ ! -f "$archive_path" ]; then
                      echo "‚ùå Failed to create archive: $repo_name"
                      rm -rf "$temp_dir"
                      return 1
                    fi
                    
                    # Upload to Azure with stdin redirected
                    if ! az storage blob upload \
                      --account-name "$AZURE_STORAGE_ACCOUNT" \
                      --account-key "$AZURE_STORAGE_KEY" \
                      --container-name "$CONTAINER_NAME" \
                      --name "$archive_name" \
                      --file "$archive_path" \
                      --overwrite \
                      --output none </dev/null 2>/dev/null; then
                      echo "‚ùå Failed to upload: $repo_name"
                      rm -rf "$temp_dir"
                      return 1
                    fi
                    
                    echo "‚úÖ Successfully backed up: $repo_name"
                    rm -rf "$temp_dir"
                    return 0
                  }

                  # Read all repositories into an array first
                  echo "üìã Reading repository list..."
                  declare -a REPOS_ARRAY

                  while IFS= read -r line; do
                    # Skip comments and empty lines
                    if [[ ! "$line" =~ ^[[:space:]]*# ]] && [[ -n "${line// }" ]]; then
                      REPOS_ARRAY+=("$line")
                    fi
                  done < repos.txt

                  TOTAL_REPOS=${#REPOS_ARRAY[@]}
                  echo "üìã Found $TOTAL_REPOS repositories to backup"
                  echo ""

                  # Process each repository from the array
                  for i in "${!REPOS_ARRAY[@]}"; do
                    repo_url="${REPOS_ARRAY[$i]}"
                    echo "[$(($i + 1))/$TOTAL_REPOS] Processing..."
                    
                    if backup_repo "$repo_url"; then
                      SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                    else
                      FAIL_COUNT=$((FAIL_COUNT + 1))
                      FAILED_REPOS="${FAILED_REPOS}$(basename "$repo_url" .git), "
                    fi
                    echo ""
                  done

                  # Clean up old backups
                  echo "üßπ Cleaning up old backups..."
                  CUTOFF_DATE=$(date -u -d "$RETENTION_DAYS days ago" +%Y-%m-%dT%H:%M:%S)

                  az storage blob list \
                    --account-name "$AZURE_STORAGE_ACCOUNT" \
                    --account-key "$AZURE_STORAGE_KEY" \
                    --container-name "$CONTAINER_NAME" \
                    --query "[?properties.lastModified < '$CUTOFF_DATE'].name" \
                    --output tsv | while read -r blob_name; do
                    if [ -n "$blob_name" ]; then
                      echo "  Deleting: $blob_name"
                      az storage blob delete \
                        --account-name "$AZURE_STORAGE_ACCOUNT" \
                        --account-key "$AZURE_STORAGE_KEY" \
                        --container-name "$CONTAINER_NAME" \
                        --name "$blob_name" \
                        --output none || true
                    fi
                  done

                  # Final summary
                  echo ""
                  echo "üìä Final Summary:"
                  echo "  Total repositories: $TOTAL_REPOS"
                  echo "  Successfully backed up: $SUCCESS_COUNT"
                  echo "  Failed: $FAIL_COUNT"

                  # Send webhook notification
                  if [ $FAIL_COUNT -eq 0 ]; then
                    send_webhook true "Backup successful: All $SUCCESS_COUNT repositories backed up"
                    echo ""
                    echo "‚úÖ Backup completed successfully!"
                  else
                    send_webhook false "Backup completed with errors: $SUCCESS_COUNT succeeded, $FAIL_COUNT failed (${FAILED_REPOS%, })"
                    echo ""
                    echo "‚ö†Ô∏è Backup completed with $FAIL_COUNT failures"
                    exit 1
                  fi
